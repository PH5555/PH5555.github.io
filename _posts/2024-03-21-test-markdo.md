---
layout: post
title: Spring - 트랜잭션
tags: [Spring, 데이터 접근 핵심 원리]
comments: true
---

## 트랜잭션 이해

우리가 데이터를 저장할 때 그냥 파일에 저장해도 되는데 데이터베이스에 저장하는 이유중 하나는 트랜잭션 때문이다. 우리가 계좌 이체 서비스를 만든다고 해보자. A이용자가 B이용자에게 2000원을 송금하면 
A이용자 계좌에서 돈이 2000원 빠져나가야하고, B이용자 계좌에서 돈이 2000원 추가 되어야한다. 이렇게 서비스의 일련의 과정을 트랜잭션이라고 하고, 데이터베이스는 이런 트랜잭션이 안정적으로 처리되도록 도와준다.
만약 에러가 발생하면 트랜잭션을 실행하기 전으로 돌아가는 `롤백`을 실행하고 정상적으로 실행되면 최종적으로 데이터를 저장하는 `커밋`을 실행한다.

## 트랜잭션 ACID

- 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.
- 일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무
결성 제약 조건을 항상 만족해야 한다.
- 격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터
를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation
level)을 선택할 수 있다.
- 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이
터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성이다. 격리성을 완전히 지키려면 트랜잭션을 차례대로 실행되어야하는데 그렇게 되면 성능이 매우 떨어질 것이다. 그래서 ANSI에서는 트랜잭션의 격리수준을 4단계로 나눈다.

- READ UNCOMMITED(커밋되지 않은 읽기)
- READ COMMITTED(커밋된 읽기)
- REPEATABLE READ(반복 가능한 읽기)
- SERIALIZABLE(직렬화 가능)

## 데이터베이스 연결 구조

![con](/assets/img/connection_session.PNG)

- 사용자는 웹 애플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 사용해서 데이터베이스 서버에 접근할
수 있다. 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 된다. 이때 데이터베이스 서버는 내
부에 세션이라는 것을 만든다. 그리고 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.

- 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다. 그리고 이후에 새로운 트랜잭션을 다
시 시작할 수 있다.

## 트랜잭션

![transaction](assets/img/tranaction.PNG)

데이터를 변경하고 그 변경 데이터를 최종적으로 저장하고 싶으면 `commit`을 실행하고 되돌리고 싶으면 `rollback`을 실행하면 된다. 이 때 커밋을 실행하기 전까지는 데이터를 임시로 보관한다.

그림처럼 한 사용자가 데이터를 변경하면 해당 세션에서만 select를 써서 조회를 할 수 있다. 

> 다른 세션에서도 해당 데이터를 접근할 수 있으면 데이터 정합성에 문제가 생긴다.

commit을 실행하면 다른 세션에서도 해당 데이터를 조회할 수 있다.

> 트랜잭션을 실행하기 전에 `Auto commit`을 false로 해주어야한다. 기본값은 true이다.

## DB락

![lock](assets/img/dblock.PNG)
